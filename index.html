import React, { useState, useEffect, useRef } from 'react';
import { Check, X, RefreshCw, Play, Star, Heart, Trophy } from 'lucide-react';

// --- 游戏数据与配置 ---

const SHAPES = {
  CIRCLE: 'circle',
  SQUARE: 'square',
  TRIANGLE: 'triangle',
  STAR: 'star',
  HEART: 'heart',
  PENTAGON: 'pentagon',
  HEXAGON: 'hexagon',
  DIAMOND: 'diamond',
  
  // 新增形状
  ARROW: 'arrow',     
  ELLIPSE: 'ellipse',   
  ONE: 'one',         
  TWO: 'two',         
  A: 'letterA',       
  B: 'letterB',       
};

const COLORS = {
  RED: '#EF4444',     // red-500
  BLUE: '#3B82F6',    // blue-500
  GREEN: '#22C55E',   // green-500
  YELLOW: '#EAB308',  // yellow-500
  PURPLE: '#A855F7',  // purple-500
  ORANGE: '#F97316',  // orange-500
  PINK: '#EC4899',    // pink-500
  TEAL: '#14B8A6',    // teal-500
  CYAN: '#06B6D4',    // cyan-500
  LIME: '#84CC16',    // lime-500
};

// 关卡设计：难度递增，共10关
const LEVELS = [
  {
    id: 1,
    name: "第一关：初次见面",
    items: [
      { id: 'l1-1', type: SHAPES.CIRCLE, color: COLORS.RED },
      { id: 'l1-2', type: SHAPES.SQUARE, color: COLORS.BLUE },
    ]
  },
  {
    id: 2,
    name: "第二关：三角朋友",
    items: [
      { id: 'l2-1', type: SHAPES.CIRCLE, color: COLORS.YELLOW },
      { id: 'l2-2', type: SHAPES.SQUARE, color: COLORS.GREEN },
      { id: 'l2-3', type: SHAPES.TRIANGLE, color: COLORS.RED },
    ]
  },
  {
    id: 3,
    name: "第三关：星星闪闪",
    items: [
      { id: 'l3-1', type: SHAPES.SQUARE, color: COLORS.ORANGE },
      { id: 'l3-2', type: SHAPES.TRIANGLE, color: COLORS.BLUE },
      { id: 'l3-3', type: SHAPES.STAR, color: COLORS.YELLOW },
      { id: 'l3-4', type: SHAPES.HEART, color: COLORS.PINK },
    ]
  },
  {
    id: 4,
    name: "第四关：更多形状",
    items: [
      { id: 'l4-1', type: SHAPES.PENTAGON, color: COLORS.PURPLE },
      { id: 'l4-2', type: SHAPES.HEXAGON, color: COLORS.TEAL },
      { id: 'l4-3', type: SHAPES.CIRCLE, color: COLORS.RED },
      { id: 'l4-4', type: SHAPES.STAR, color: COLORS.YELLOW },
      { id: 'l4-5', type: SHAPES.DIAMOND, color: COLORS.BLUE },
    ]
  },
  {
    id: 5,
    name: "第五关：彩虹挑战",
    items: [
      { id: 'l5-1', type: SHAPES.HEART, color: COLORS.RED },
      { id: 'l5-2', type: SHAPES.STAR, color: COLORS.YELLOW },
      { id: 'l5-3', type: SHAPES.TRIANGLE, color: COLORS.GREEN },
      { id: 'l5-4', type: SHAPES.SQUARE, color: COLORS.BLUE },
      { id: 'l5-5', type: SHAPES.CIRCLE, color: COLORS.PURPLE },
      { id: 'l5-6', type: SHAPES.PENTAGON, color: COLORS.ORANGE },
    ]
  },
  // --- 新增关卡 6-10 ---
  {
    id: 6,
    name: "第六关：新几何体",
    items: [
      { id: 'l6-1', type: SHAPES.ELLIPSE, color: COLORS.PINK }, // 椭圆
      { id: 'l6-2', type: SHAPES.ARROW, color: COLORS.ORANGE }, // 箭头
      { id: 'l6-3', type: SHAPES.SQUARE, color: COLORS.TEAL },
      { id: 'l6-4', type: SHAPES.HEART, color: COLORS.PURPLE },
    ]
  },
  {
    id: 7,
    name: "第七关：颜色挑战", // 相同形状，不同颜色，必须严格匹配颜色
    items: [
      { id: 'l7-1', type: SHAPES.CIRCLE, color: COLORS.RED },
      { id: 'l7-2', type: SHAPES.CIRCLE, color: COLORS.CYAN },
      { id: 'l7-3', type: SHAPES.TRIANGLE, color: COLORS.GREEN },
      { id: 'l7-4', type: SHAPES.TRIANGLE, color: COLORS.YELLOW },
    ]
  },
  {
    id: 8,
    name: "第八关：数字时间",
    items: [
      { id: 'l8-1', type: SHAPES.ONE, color: COLORS.PURPLE }, // 数字 1
      { id: 'l8-2', type: SHAPES.TWO, color: COLORS.ORANGE }, // 数字 2
      { id: 'l8-3', type: SHAPES.DIAMOND, color: COLORS.PINK },
      { id: 'l8-4', type: SHAPES.ELLIPSE, color: COLORS.TEAL },
      { id: 'l8-5', type: SHAPES.STAR, color: COLORS.RED },
    ]
  },
  {
    id: 9,
    name: "第九关：字母积木",
    items: [
      { id: 'l9-1', type: SHAPES.A, color: COLORS.GREEN }, // 字母 A
      { id: 'l9-2', type: SHAPES.B, color: COLORS.YELLOW }, // 字母 B
      { id: 'l9-3', type: SHAPES.CIRCLE, color: COLORS.BLUE },
      { id: 'l9-4', type: SHAPES.DIAMOND, color: COLORS.LIME },
      { id: 'l9-5', type: SHAPES.ARROW, color: COLORS.PURPLE },
      { id: 'l9-6', type: SHAPES.HEXAGON, color: COLORS.ORANGE },
    ]
  },
  {
    id: 10,
    name: "第十关：最终挑战",
    items: [
      { id: 'l10-1', type: SHAPES.ELLIPSE, color: COLORS.RED },
      { id: 'l10-2', type: SHAPES.ONE, color: COLORS.BLUE },
      { id: 'l10-3', type: SHAPES.A, color: COLORS.GREEN },
      { id: 'l10-4', type: SHAPES.STAR, color: COLORS.YELLOW },
      { id: 'l10-5', type: SHAPES.HEXAGON, color: COLORS.PURPLE },
      { id: 'l10-6', type: SHAPES.SQUARE, color: COLORS.ORANGE },
      { id: 'l10-7', type: SHAPES.HEART, color: COLORS.PINK }, // 挑战 7 个积木
    ]
  }
];

// --- 图形组件 ---
const ShapeSvg = ({ type, color, className = "", style = {} }) => {
  // 对于文字形状，使用 currentColor 确保文字颜色与 fill 相同
  const commonProps = { fill: color, className: className, style: style };
  
  switch (type) {
    case SHAPES.CIRCLE:
      return <svg viewBox="0 0 100 100" {...commonProps}><circle cx="50" cy="50" r="45" /></svg>;
    case SHAPES.SQUARE:
      return <svg viewBox="0 0 100 100" {...commonProps}><rect x="10" y="10" width="80" height="80" rx="10" /></svg>;
    case SHAPES.TRIANGLE:
      // 使用 stroke 增加圆润感
      return <svg viewBox="0 0 100 100" {...commonProps}><path d="M50 10 L90 85 L10 85 Z" strokeLinejoin="round" strokeWidth="10" stroke={color}/></svg>; 
    case SHAPES.STAR:
      return <svg viewBox="0 0 100 100" {...commonProps}><path d="M50 10 L61 39 L92 39 L67 57 L76 86 L50 67 L24 86 L33 57 L8 39 L39 39 Z" strokeLinejoin="round" strokeWidth="5" stroke={color} /></svg>;
    case SHAPES.HEART:
      return <svg viewBox="0 0 100 100" {...commonProps}><path d="M50 85 C50 85 10 60 10 35 C10 20 25 10 40 20 C45 23 50 30 50 30 C50 30 55 23 60 20 C75 10 90 20 90 35 C90 60 50 85 50 85 Z" /></svg>;
    case SHAPES.PENTAGON:
      return <svg viewBox="0 0 100 100" {...commonProps}><path d="M50 10 L90 40 L75 90 L25 90 L10 40 Z" /></svg>;
    case SHAPES.HEXAGON:
      return <svg viewBox="0 0 100 100" {...commonProps}><path d="M25 10 L75 10 L95 50 L75 90 L25 90 L5 50 Z" /></svg>;
    case SHAPES.DIAMOND:
      return <svg viewBox="0 0 100 100" {...commonProps}><path d="M50 10 L85 50 L50 90 L15 50 Z" /></svg>;
      
    // 新增几何图形
    case SHAPES.ARROW:
      // 简单的上箭头
      return <svg viewBox="0 0 100 100" {...commonProps}><path d="M50 10 L80 40 L65 40 L65 90 L35 90 L35 40 L20 40 Z" /></svg>;
    case SHAPES.ELLIPSE:
      return <svg viewBox="0 0 100 100" {...commonProps}><ellipse cx="50" cy="50" rx="45" ry="35" /></svg>;
      
    // 数字和字母 (使用文字)
    case SHAPES.ONE:
      return <svg viewBox="0 0 100 100" {...commonProps}><text x="50" y="75" fill="currentColor" fontSize="80" textAnchor="middle" fontWeight="900">1</text></svg>;
    case SHAPES.TWO:
      return <svg viewBox="0 0 100 100" {...commonProps}><text x="50" y="75" fill="currentColor" fontSize="80" textAnchor="middle" fontWeight="900">2</text></svg>;
    case SHAPES.A:
      return <svg viewBox="0 0 100 100" {...commonProps}><text x="50" y="75" fill="currentColor" fontSize="80" textAnchor="middle" fontWeight="900">A</text></svg>;
    case SHAPES.B:
      return <svg viewBox="0 0 100 100" {...commonProps}><text x="50" y="75" fill="currentColor" fontSize="80" textAnchor="middle" fontWeight="900">B</text></svg>;
      
    default:
      return <div className={`w-full h-full bg-gray-400 rounded-full ${className}`} />;
  }
};

// --- 主程序 ---

export default function ShapeSorterGame() {
  const [currentLevelIdx, setCurrentLevelIdx] = useState(0);
  // placedItems now stores the item ID if it is correctly placed
  const [placedItems, setPlacedItems] = useState({}); 
  const [isLevelComplete, setIsLevelComplete] = useState(false);
  const [shuffledPieces, setShuffledPieces] = useState([]);
  const [feedback, setFeedback] = useState(null); // { type: 'success' | 'error', x, y }

  // Dragging state
  const [draggingItem, setDraggingItem] = useState(null);
  const [dragPosition, setDragPosition] = useState({ x: 0, y: 0 });
  const dragOffset = useRef({ x: 0, y: 0 });

  // Refs for slot positions
  const slotsRef = useRef({});

  // Initialize Level
  useEffect(() => {
    startLevel(currentLevelIdx);
  }, [currentLevelIdx]);

  const startLevel = (idx) => {
    // 确保索引在有效范围内
    if (idx < 0 || idx >= LEVELS.length) {
        idx = 0; // 超过则回到第一关
    }
    
    const level = LEVELS[idx];
    setPlacedItems({});
    setIsLevelComplete(false);
    
    // Shuffle pieces for the bottom area
    const pieces = [...level.items].sort(() => Math.random() - 0.5);
    setShuffledPieces(pieces);
    setFeedback(null);
  };

  const handleLevelComplete = () => {
    setIsLevelComplete(true);
  };

  const nextLevel = () => {
    if (currentLevelIdx < LEVELS.length - 1) {
      setCurrentLevelIdx(prev => prev + 1);
    } else {
      // 完成所有关卡后，回到第一关
      setCurrentLevelIdx(0); 
    }
  };

  // --- Drag & Drop Logic (Touch & Mouse compatible) ---

  const handlePointerDown = (e, item) => {
    // Prevent default to stop scrolling on touch devices while dragging blocks
    e.preventDefault(); 
    
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    // Calculate offset so the item doesn't jump to center of cursor
    const targetRect = e.target.getBoundingClientRect();
    dragOffset.current = {
      x: clientX - targetRect.left,
      y: clientY - targetRect.top
    };

    setDraggingItem(item);
    setDragPosition({ 
      x: clientX - dragOffset.current.x, 
      y: clientY - dragOffset.current.y 
    });
  };

  const handlePointerMove = (e) => {
    if (!draggingItem) return;
    e.preventDefault();

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    setDragPosition({
      x: clientX - dragOffset.current.x,
      y: clientY - dragOffset.current.y
    });
  };

  const handlePointerUp = (e) => {
    if (!draggingItem) return;

    // Assuming drag block size is 80x80 (w-20/h-20 sm:w-24/h-24 -> 80/96px on desktop)
    // We use 40 as a rough center offset for collision check
    const dropX = dragPosition.x + 40; 
    const dropY = dragPosition.y + 40;

    let matched = false;

    // Check collision with slots
    const levelItems = LEVELS[currentLevelIdx].items;
    
    for (const targetItem of levelItems) {
      // Find the slot element corresponding to the target item
      const slotEl = slotsRef.current[targetItem.id];
      if (slotEl) {
        const rect = slotEl.getBoundingClientRect();
        
        // Simple bounding box collision: Is the dropped piece center near the slot?
        if (
          dropX >= rect.left && 
          dropX <= rect.right && 
          dropY >= rect.top && 
          dropY <= rect.bottom
        ) {
          
          // --- 严格匹配逻辑: 形状和颜色必须同时匹配 ---
          if (targetItem.type === draggingItem.type && targetItem.color === draggingItem.color) {
             // Success! 形状和颜色都正确
             setPlacedItems(prev => {
                const newPlaced = { ...prev, [draggingItem.id]: true };
                // Check win condition immediately
                if (Object.keys(newPlaced).length === levelItems.length) {
                   setTimeout(handleLevelComplete, 500);
                }
                return newPlaced;
             });
             // 成功反馈动画位置
             setFeedback({ type: 'success', x: rect.left + rect.width/2, y: rect.top + rect.height/2 });
             matched = true;
          } else {
             // Wrong slot - 形状或颜色不匹配
             // 失败反馈动画位置
             setFeedback({ type: 'error', x: rect.left + rect.width/2, y: rect.top + rect.height/2 });
          }
          break; // Exit loop once found a slot we are hovering
        }
      }
    }

    // Clear feedback after a moment
    if (matched || !matched) {
       setTimeout(() => setFeedback(null), 1000);
    }

    setDraggingItem(null);
  };

  // Attach global move/up listeners when dragging
  useEffect(() => {
    if (draggingItem) {
      window.addEventListener('pointermove', handlePointerMove, { passive: false });
      window.addEventListener('pointerup', handlePointerUp);
      window.addEventListener('touchmove', handlePointerMove, { passive: false });
      window.addEventListener('touchend', handlePointerUp);
    }
    return () => {
      window.removeEventListener('pointermove', handlePointerMove);
      window.removeEventListener('pointerup', handlePointerUp);
      window.removeEventListener('touchmove', handlePointerMove);
      window.removeEventListener('touchend', handlePointerUp);
    };
  }, [draggingItem, dragPosition]);


  const currentLevelData = LEVELS[currentLevelIdx];

  // 计算当前关卡已放置的数量
  const placedCount = Object.keys(placedItems).length;

  return (
    <div className="flex flex-col h-screen bg-blue-50 select-none overflow-hidden touch-none font-sans">
      
      {/* 顶部栏 */}
      <div className="bg-white p-4 shadow-sm flex justify-between items-center z-10">
        <div className="flex items-center gap-2">
           <div className="bg-yellow-400 p-2 rounded-full text-white font-bold text-xl w-10 h-10 flex items-center justify-center">
             {currentLevelIdx + 1}/{LEVELS.length}
           </div>
           <span className="text-gray-700 font-bold text-lg hidden sm:block">{currentLevelData.name}</span>
           <span className="text-sm text-blue-500 font-semibold ml-4">已完成: {placedCount}/{currentLevelData.items.length}</span>
        </div>
        <button 
          onClick={() => startLevel(currentLevelIdx)}
          className="p-2 bg-gray-100 rounded-full hover:bg-gray-200 active:scale-95 transition-all text-gray-600"
          title="重新开始本关"
        >
          <RefreshCw size={24} />
        </button>
      </div>

      {/* 游戏主区域 */}
      <div className="flex-1 flex flex-col relative max-w-4xl mx-auto w-full">
        
        {/* 上半部分：目标模型区域 */}
        <div className="flex-1 bg-white/50 m-4 rounded-3xl border-4 border-dashed border-blue-200 flex items-center justify-center relative shadow-inner">
           <div className="absolute top-2 left-4 text-blue-300 font-bold uppercase tracking-widest text-sm">在这里拼图 (形状和颜色都要匹配哦!)</div>
           
           <div className="flex flex-wrap gap-8 justify-center items-center p-4">
              {currentLevelData.items.map((item) => (
                <div 
                  key={item.id}
                  ref={el => slotsRef.current[item.id] = el}
                  className={`relative w-24 h-24 sm:w-32 sm:h-32 transition-all duration-500 ${placedItems[item.id] ? 'scale-110' : ''}`}
                >
                  {/* The Outline/Hole: Color is now part of the outline to guide the strict match */}
                  <div className="absolute inset-0 opacity-20 transform scale-105">
                     <ShapeSvg type={item.type} color={item.color} />
                  </div>
                  
                  {/* The Placed Item (if successful) */}
                  {placedItems[item.id] && (
                     <div className="absolute inset-0 animate-bounce-short z-10">
                        <ShapeSvg type={item.type} color={item.color} className="drop-shadow-xl" />
                        <div className="absolute -top-2 -right-2 bg-green-500 text-white rounded-full p-1 shadow-lg transform scale-0 animate-pop-in" style={{animationFillMode: 'forwards'}}>
                           <Check size={20} strokeWidth={4} />
                        </div>
                     </div>
                  )}
                </div>
              ))}
           </div>
        </div>

        {/* 下半部分：拖动木块区域 */}
        <div className="h-48 sm:h-60 bg-amber-100 rounded-t-3xl border-t-8 border-amber-200 shadow-[0_-4px_20px_rgba(0,0,0,0.1)] flex flex-col z-20">
           <div className="text-center pt-2 text-amber-700/50 font-bold text-sm">拖动积木到上面的形状里</div>
           <div className="flex-1 flex flex-wrap gap-4 sm:gap-8 justify-center items-center p-4 content-center">
              {shuffledPieces.map((item) => {
                 // Hide if already placed
                 if (placedItems[item.id]) return null;

                 // Hide if currently being dragged (we render the drag layer instead)
                 const isDraggingThis = draggingItem?.id === item.id;

                 return (
                   <div 
                      key={item.id}
                      className={`w-20 h-20 sm:w-24 sm:h-24 cursor-grab active:cursor-grabbing transform transition-transform hover:scale-105 ${isDraggingThis ? 'opacity-0' : 'opacity-100'}`}
                      onPointerDown={(e) => handlePointerDown(e, item)}
                   >
                      {/* Visual styling to make it look like a wooden block 3D */}
                      <div className="w-full h-full relative">
                         {/* Shadow/Depth */}
                         <div className="absolute top-1 left-1 w-full h-full">
                            <ShapeSvg type={item.type} color="#ededed" />
                         </div>
                         {/* Actual Block */}
                         <div className="absolute top-0 left-0 w-full h-full filter drop-shadow-md">
                            <ShapeSvg type={item.type} color={item.color} />
                         </div>
                         {/* Shine effect */}
                         <div className="absolute top-2 left-2 w-1/3 h-1/3 bg-white opacity-20 rounded-full blur-sm"></div>
                      </div>
                   </div>
                 );
              })}
           </div>
        </div>

      </div>

      {/* 拖动时的浮层 (Draggable Layer) */}
      {draggingItem && (
        <div 
          className="fixed pointer-events-none z-50 w-24 h-24 filter drop-shadow-2xl opacity-90"
          style={{ 
            left: dragPosition.x, 
            top: dragPosition.y,
            transform: 'scale(1.2)' 
          }}
        >
          <ShapeSvg type={draggingItem.type} color={draggingItem.color} />
        </div>
      )}

      {/* 反馈特效 (√ 或 ×) */}
      {feedback && (
         <div 
            className="fixed pointer-events-none z-50 animate-fade-out"
            style={{ 
               left: feedback.x - 24, // center it
               top: feedback.y - 24,
            }}
         >
            {feedback.type === 'success' ? (
               <Check size={48} className="text-green-500 drop-shadow-lg" strokeWidth={4} />
            ) : (
               <X size={48} className="text-red-500 drop-shadow-lg" strokeWidth={4} />
            )}
         </div>
      )}

      {/* 过关模态框 */}
      {isLevelComplete && (
        <div className="absolute inset-0 bg-black/60 flex items-center justify-center z-50 backdrop-blur-sm animate-fade-in">
          <div className="bg-white rounded-3xl p-8 max-w-sm w-[90%] text-center shadow-2xl transform scale-100 animate-bounce-in relative overflow-hidden">
            {/* Background rays */}
            <div className="absolute inset-0 bg-yellow-100 opacity-50 z-0"></div>
            
            <div className="relative z-10 flex flex-col items-center">
               <div className="mb-4 text-yellow-500 animate-spin-slow">
                  {currentLevelIdx === LEVELS.length - 1 ? (
                    <Trophy size={64} fill="currentColor" /> // 最后一关用奖杯
                  ) : (
                    <Star size={64} fill="currentColor" /> // 其他关卡用星星
                  )}
               </div>
               <h2 className="text-3xl font-black text-gray-800 mb-2">
                 {currentLevelIdx === LEVELS.length - 1 ? "恭喜你，完成所有挑战！" : "太棒了!"}
               </h2>
               <p className="text-gray-500 mb-8">你完成了{currentLevelData.name}</p>
               
               <div className="flex gap-4 w-full">
                 <button 
                   onClick={() => startLevel(currentLevelIdx)}
                   className="flex-1 py-3 rounded-xl bg-gray-100 text-gray-600 font-bold text-lg hover:bg-gray-200 transition-colors"
                 >
                   再玩一次
                 </button>
                 <button 
                   onClick={nextLevel}
                   className="flex-1 py-3 rounded-xl bg-blue-500 text-white font-bold text-lg shadow-lg shadow-blue-500/30 hover:bg-blue-600 hover:scale-105 transition-all flex items-center justify-center gap-2"
                 >
                   <Play size={20} fill="currentColor" />
                   {currentLevelIdx === LEVELS.length - 1 ? "重玩全部" : "下一关"}
                 </button>
               </div>
            </div>
          </div>
          {/* Simple confetti dots (CSS driven) */}
          <div className="absolute top-10 left-10 w-4 h-4 bg-red-500 rounded-full animate-ping"></div>
          <div className="absolute top-20 right-20 w-3 h-3 bg-blue-500 rounded-full animate-ping delay-100"></div>
          <div className="absolute bottom-40 left-1/3 w-5 h-5 bg-green-500 rounded-full animate-ping delay-200"></div>
        </div>
      )}

      {/* Global Styles for Animations */}
      <style>{`
        @keyframes pop-in {
          0% { transform: scale(0); }
          80% { transform: scale(1.2); }
          100% { transform: scale(1); }
        }
        @keyframes bounce-short {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-10px); }
        }
        @keyframes spin-slow {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        @keyframes fade-out {
          0% { opacity: 1; transform: scale(1); }
          100% { opacity: 0; transform: scale(1.5); }
        }
        @keyframes bounce-in {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); opacity: 1; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }
        .animate-pop-in { animation: pop-in 0.3s ease-out forwards; }
        .animate-bounce-short { animation: bounce-short 0.5s ease-in-out; }
        .animate-spin-slow { animation: spin-slow 3s linear infinite; }
        .animate-fade-out { animation: fade-out 0.8s ease-out forwards; }
        .animate-bounce-in { animation: bounce-in 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
      `}</style>

    </div>
  );

}
