<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>形状与颜色排序游戏 - 10关挑战</title>
    <!-- 引入 Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Lucide Icons 库 -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* 使用 Inter 字体作为首选，增强现代感 */
        :root {
            font-family: 'Inter', sans-serif;
        }

        /* 基础动画定义 (与React版本保持一致) */
        @keyframes pop-in {
          0% { transform: scale(0); }
          80% { transform: scale(1.2); }
          100% { transform: scale(1); }
        }
        @keyframes bounce-short {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-10px); }
        }
        @keyframes spin-slow {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        @keyframes fade-out {
          0% { opacity: 1; transform: scale(1); }
          100% { opacity: 0; transform: scale(1.5); }
        }
        @keyframes bounce-in {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); opacity: 1; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        .animate-pop-in { animation: pop-in 0.3s ease-out forwards; }
        .animate-bounce-short { animation: bounce-short 0.5s ease-in-out; }
        .animate-spin-slow { animation: spin-slow 3s linear infinite; }
        .animate-fade-out { animation: fade-out 0.8s ease-out forwards; }
        .animate-bounce-in { animation: bounce-in 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55); }

        /* 强制 body 占满视口高度，确保游戏区域正确布局 */
        body {
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* 3D 积木效果的简化 CSS */
        .block-3d-effect {
            position: relative;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
        }
        .block-3d-effect > svg {
             /* 确保 SVG 填满容器 */
            width: 100%;
            height: 100%;
        }
        .block-3d-effect:active {
            filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.3));
            transform: translateY(1px); /* 按下时的微小位移感 */
        }
    </style>
</head>
<body class="bg-blue-50 select-none touch-none">

    <div id="game-container" class="flex flex-col h-screen max-w-4xl mx-auto w-full overflow-hidden">
        
        <!-- 顶部栏 -->
        <div id="header" class="bg-white p-4 shadow-sm flex justify-between items-center z-10">
            <!-- Content will be rendered by JS -->
        </div>

        <!-- 游戏主区域 -->
        <div class="flex-1 flex flex-col relative w-full">
            
            <!-- 上半部分：目标模型区域 (Slots) -->
            <div id="slots-container" class="flex-1 bg-white/50 m-4 rounded-3xl border-4 border-dashed border-blue-200 flex items-center justify-center relative shadow-inner">
               <div class="absolute top-2 left-4 text-blue-300 font-bold uppercase tracking-widest text-sm">在这里拼图 (形状和颜色都要匹配哦!)</div>
               <div id="slots-grid" class="flex flex-wrap gap-8 justify-center items-center p-4">
                  <!-- Slots rendered by JS -->
               </div>
            </div>

            <!-- 下半部分：拖动木块区域 (Pieces) -->
            <div id="pieces-container" class="h-48 sm:h-60 bg-amber-100 rounded-t-3xl border-t-8 border-amber-200 shadow-[0_-4px_20px_rgba(0,0,0,0.1)] flex flex-col z-20">
               <div class="text-center pt-2 text-amber-700/50 font-bold text-sm">拖动积木到上面的形状里</div>
               <div id="pieces-grid" class="flex-1 flex flex-wrap gap-4 sm:gap-8 justify-center items-center p-4 content-center">
                  <!-- Pieces rendered by JS -->
               </div>
            </div>

        </div>

        <!-- 拖动时的浮层 (Draggable Layer) -->
        <div id="drag-layer" class="fixed pointer-events-none z-50 w-24 h-24 filter drop-shadow-2xl opacity-90 hidden">
            <!-- Dragged item SVG rendered by JS -->
        </div>

        <!-- 反馈特效 (√ 或 ×) -->
        <div id="feedback-layer" class="fixed pointer-events-none z-50 hidden">
             <!-- Feedback icon rendered by JS -->
        </div>

        <!-- 过关模态框 -->
        <div id="level-complete-modal" class="absolute inset-0 bg-black/60 flex items-center justify-center z-50 backdrop-blur-sm hidden animate-fade-in">
            <!-- Modal content rendered by JS -->
        </div>

    </div>

    <script>
        // --- 图标 SVG 辅助函数 (修复了 toSvg 错误) ---
        /**
         * 安全地获取 Lucide 图标的 SVG 字符串
         * @param {string} iconName 图标名称
         * @param {Object} attributes 属性，如 width, height, class, strokeWidth 等
         * @returns {string} SVG 字符串或空字符串
         */
        function getLucideSvgString(iconName, attributes = {}) {
            // Lucide CDN 导出的图标是函数，需要调用并序列化
            const iconFn = lucide.icons[iconName];
            if (typeof iconFn === 'function') {
                try {
                    // 调用 icon 函数，它返回一个 SVG DOM 元素
                    const svgElement = iconFn(attributes);
                    
                    // 序列化 DOM 元素到 SVG 字符串
                    // 确保使用 new XMLSerializer() 在浏览器环境中工作
                    return new XMLSerializer().serializeToString(svgElement);
                } catch (e) {
                    console.error(`Error generating SVG for ${iconName}:`, e);
                }
            }
            return ''; 
        }

        // --- 游戏数据与配置 (与 React 版本保持一致) ---
        const SHAPES = {
            CIRCLE: 'circle', SQUARE: 'square', TRIANGLE: 'triangle', STAR: 'star',
            HEART: 'heart', PENTAGON: 'pentagon', HEXAGON: 'hexagon', DIAMOND: 'diamond',
            ARROW: 'arrow', ELLIPSE: 'ellipse', ONE: 'one', TWO: 'two', A: 'letterA', B: 'letterB',
        };

        const COLORS = {
            RED: '#EF4444', BLUE: '#3B82F6', GREEN: '#22C55E', YELLOW: '#EAB308',
            PURPLE: '#A855F7', ORANGE: '#F97316', PINK: '#EC4899', TEAL: '#14B8A6',
            CYAN: '#06B6D4', LIME: '#84CC16',
        };

        const LEVELS = [
            { id: 1, name: "第一关：初次见面", items: [{ id: 'l1-1', type: SHAPES.CIRCLE, color: COLORS.RED }, { id: 'l1-2', type: SHAPES.SQUARE, color: COLORS.BLUE }] },
            { id: 2, name: "第二关：三角朋友", items: [{ id: 'l2-1', type: SHAPES.CIRCLE, color: COLORS.YELLOW }, { id: 'l2-2', type: SHAPES.SQUARE, color: COLORS.GREEN }, { id: 'l2-3', type: SHAPES.TRIANGLE, color: COLORS.RED }] },
            { id: 3, name: "第三关：星星闪闪", items: [{ id: 'l3-1', type: SHAPES.SQUARE, color: COLORS.ORANGE }, { id: 'l3-2', type: SHAPES.TRIANGLE, color: COLORS.BLUE }, { id: 'l3-3', type: SHAPES.STAR, color: COLORS.YELLOW }, { id: 'l3-4', type: SHAPES.HEART, color: COLORS.PINK }] },
            { id: 4, name: "第四关：更多形状", items: [{ id: 'l4-1', type: SHAPES.PENTAGON, color: COLORS.PURPLE }, { id: 'l4-2', type: SHAPES.HEXAGON, color: COLORS.TEAL }, { id: 'l4-3', type: SHAPES.CIRCLE, color: COLORS.RED }, { id: 'l4-4', type: SHAPES.STAR, color: COLORS.YELLOW }, { id: 'l4-5', type: SHAPES.DIAMOND, color: COLORS.BLUE }] },
            { id: 5, name: "第五关：彩虹挑战", items: [{ id: 'l5-1', type: SHAPES.HEART, color: COLORS.RED }, { id: 'l5-2', type: SHAPES.STAR, color: COLORS.YELLOW }, { id: 'l5-3', type: SHAPES.TRIANGLE, color: COLORS.GREEN }, { id: 'l5-4', type: SHAPES.SQUARE, color: COLORS.BLUE }, { id: 'l5-5', type: SHAPES.CIRCLE, color: COLORS.PURPLE }, { id: 'l5-6', type: SHAPES.PENTAGON, color: COLORS.ORANGE }] },
            { id: 6, name: "第六关：新几何体", items: [{ id: 'l6-1', type: SHAPES.ELLIPSE, color: COLORS.PINK }, { id: 'l6-2', type: SHAPES.ARROW, color: COLORS.ORANGE }, { id: 'l6-3', type: SHAPES.SQUARE, color: COLORS.TEAL }, { id: 'l6-4', type: SHAPES.HEART, color: COLORS.PURPLE }] },
            { id: 7, name: "第七关：颜色挑战", items: [{ id: 'l7-1', type: SHAPES.CIRCLE, color: COLORS.RED }, { id: 'l7-2', type: SHAPES.CIRCLE, color: COLORS.CYAN }, { id: 'l7-3', type: SHAPES.TRIANGLE, color: COLORS.GREEN }, { id: 'l7-4', type: SHAPES.TRIANGLE, color: COLORS.YELLOW }] },
            { id: 8, name: "第八关：数字时间", items: [{ id: 'l8-1', type: SHAPES.ONE, color: COLORS.PURPLE }, { id: 'l8-2', type: SHAPES.TWO, color: COLORS.ORANGE }, { id: 'l8-3', type: SHAPES.DIAMOND, color: COLORS.PINK }, { id: 'l8-4', type: SHAPES.ELLIPSE, color: COLORS.TEAL }, { id: 'l8-5', type: SHAPES.STAR, color: COLORS.RED }] },
            { id: 9, name: "第九关：字母积木", items: [{ id: 'l9-1', type: SHAPES.A, color: COLORS.GREEN }, { id: 'l9-2', type: SHAPES.B, color: COLORS.YELLOW }, { id: 'l9-3', type: SHAPES.CIRCLE, color: COLORS.BLUE }, { id: 'l9-4', type: SHAPES.DIAMOND, color: COLORS.LIME }, { id: 'l9-5', type: SHAPES.ARROW, color: COLORS.PURPLE }, { id: 'l9-6', type: SHAPES.HEXAGON, color: COLORS.ORANGE }] },
            { id: 10, name: "第十关：最终挑战", items: [{ id: 'l10-1', type: SHAPES.ELLIPSE, color: COLORS.RED }, { id: 'l10-2', type: SHAPES.ONE, color: COLORS.BLUE }, { id: 'l10-3', type: SHAPES.A, color: COLORS.GREEN }, { id: 'l10-4', type: SHAPES.STAR, color: COLORS.YELLOW }, { id: 'l10-5', type: SHAPES.HEXAGON, color: COLORS.PURPLE }, { id: 'l10-6', type: SHAPES.SQUARE, color: COLORS.ORANGE }, { id: 'l10-7', type: SHAPES.HEART, color: COLORS.PINK }] }
        ];

        // --- 游戏状态 ---
        let gameState = {
            currentLevelIdx: 0,
            placedItems: {}, // Key: itemId, Value: true
            shuffledPieces: [],
            draggingItem: null, // {id, type, color}
            dragOffset: { x: 0, y: 0 },
            dragPosition: { x: 0, y: 0 },
            slotsRects: {}, // Stores bounding boxes of slots
        };

        // --- DOM 元素引用 ---
        const DOMElements = {
            header: document.getElementById('header'),
            slotsGrid: document.getElementById('slots-grid'),
            piecesGrid: document.getElementById('pieces-grid'),
            dragLayer: document.getElementById('drag-layer'),
            feedbackLayer: document.getElementById('feedback-layer'),
            modal: document.getElementById('level-complete-modal'),
        };

        // --- 图形 SVG 生成函数 ---

        /**
         * 根据形状和颜色生成 SVG 字符串
         * @param {string} type 形状类型
         * @param {string} color 颜色代码
         * @param {string} className 附加的 CSS 类
         * @returns {string} SVG 字符串
         */
        function createShapeSvg(item, className = "") {
            const { type, color } = item;
            let pathContent = '';
            
            // 文本和数字使用 currentColor，让 SVG 继承 CSS 样式，但为了兼容性，直接用 color 作为 fill
            const isTextShape = type.startsWith('letter') || type.startsWith('one') || type.startsWith('two');
            const fill = color; 
            
            switch (type) {
                case SHAPES.CIRCLE:
                    pathContent = `<circle cx="50" cy="50" r="45" fill="${fill}" />`;
                    break;
                case SHAPES.SQUARE:
                    pathContent = `<rect x="10" y="10" width="80" height="80" rx="10" fill="${fill}" />`;
                    break;
                case SHAPES.TRIANGLE:
                    // 复制 React 版本的 stroke 效果以增加圆润感
                    pathContent = `<path d="M50 10 L90 85 L10 85 Z" stroke-linejoin="round" stroke-width="10" stroke="${fill}" fill="${fill}" />`;
                    break;
                case SHAPES.STAR:
                    // 复制 React 版本的 stroke 效果
                    pathContent = `<path d="M50 10 L61 39 L92 39 L67 57 L76 86 L50 67 L24 86 L33 57 L8 39 L39 39 Z" stroke-linejoin="round" stroke-width="5" stroke="${fill}" fill="${fill}" />`;
                    break;
                case SHAPES.HEART:
                    pathContent = `<path d="M50 85 C50 85 10 60 10 35 C10 20 25 10 40 20 C45 23 50 30 50 30 C50 30 55 23 60 20 C75 10 90 20 90 35 C90 60 50 85 50 85 Z" fill="${fill}" />`;
                    break;
                case SHAPES.PENTAGON:
                    pathContent = `<path d="M50 10 L90 40 L75 90 L25 90 L10 40 Z" fill="${fill}" />`;
                    break;
                case SHAPES.HEXAGON:
                    pathContent = `<path d="M25 10 L75 10 L95 50 L75 90 L25 90 L5 50 Z" fill="${fill}" />`;
                    break;
                case SHAPES.DIAMOND:
                    pathContent = `<path d="M50 10 L85 50 L50 90 L15 50 Z" fill="${fill}" />`;
                    break;
                case SHAPES.ARROW:
                    pathContent = `<path d="M50 10 L80 40 L65 40 L65 90 L35 90 L35 40 L20 40 Z" fill="${fill}" />`;
                    break;
                case SHAPES.ELLIPSE:
                    pathContent = `<ellipse cx="50" cy="50" rx="45" ry="35" fill="${fill}" />`;
                    break;
                case SHAPES.ONE:
                    pathContent = `<text x="50" y="75" fill="${fill}" font-size="80" text-anchor="middle" font-weight="900">1</text>`;
                    break;
                case SHAPES.TWO:
                    pathContent = `<text x="50" y="75" fill="${fill}" font-size="80" text-anchor="middle" font-weight="900">2</text>`;
                    break;
                case SHAPES.A:
                    pathContent = `<text x="50" y="75" fill="${fill}" font-size="80" text-anchor="middle" font-weight="900">A</text>`;
                    break;
                case SHAPES.B:
                    pathContent = `<text x="50" y="75" fill="${fill}" font-size="80" text-anchor="middle" font-weight="900">B</text>`;
                    break;
                default:
                    return `<div class="w-full h-full bg-gray-400 rounded-full ${className}"></div>`;
            }

            return `<svg viewBox="0 0 100 100" class="w-full h-full ${className}">${pathContent}</svg>`;
        }

        // --- 游戏逻辑 ---

        /** * 随机打乱数组 
         * @param {Array} array
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function startLevel(idx) {
            if (idx < 0 || idx >= LEVELS.length) {
                idx = 0; 
            }
            gameState.currentLevelIdx = idx;
            gameState.placedItems = {};
            
            const level = LEVELS[idx];
            // 复制并打乱积木列表
            gameState.shuffledPieces = shuffleArray([...level.items]);

            DOMElements.modal.classList.add('hidden');
            renderGame();
        }

        function handleLevelComplete() {
            renderModal();
            DOMElements.modal.classList.remove('hidden');
        }

        function nextLevel() {
            if (gameState.currentLevelIdx < LEVELS.length - 1) {
                startLevel(gameState.currentLevelIdx + 1);
            } else {
                // 完成所有关卡后，回到第一关
                startLevel(0); 
            }
        }

        // --- 渲染函数 ---

        function renderHeader() {
            const currentLevelData = LEVELS[gameState.currentLevelIdx];
            const totalItems = currentLevelData.items.length;
            const placedCount = Object.keys(gameState.placedItems).length;

            DOMElements.header.innerHTML = `
                <div class="flex items-center gap-2">
                   <div class="bg-yellow-400 p-2 rounded-full text-white font-bold text-xl w-10 h-10 flex items-center justify-center">
                     ${gameState.currentLevelIdx + 1}/${LEVELS.length}
                   </div>
                   <span class="text-gray-700 font-bold text-lg hidden sm:block">${currentLevelData.name}</span>
                   <span class="text-sm text-blue-500 font-semibold ml-4">已完成: ${placedCount}/${totalItems}</span>
                </div>
                <button 
                  onclick="startLevel(${gameState.currentLevelIdx})"
                  class="p-2 bg-gray-100 rounded-full hover:bg-gray-200 active:scale-95 transition-all text-gray-600"
                  title="重新开始本关"
                >
                  ${getLucideSvgString('refresh-cw', { width: 24, height: 24 })}
                </button>
            `;
        }

        function renderSlots() {
            const currentLevelData = LEVELS[gameState.currentLevelIdx];
            gameState.slotsRects = {}; // Reset positions

            DOMElements.slotsGrid.innerHTML = currentLevelData.items.map(item => {
                const isPlaced = gameState.placedItems[item.id];
                
                // 占位图形 (Opacity 20)
                const outlineSvg = createShapeSvg(item, 'opacity-20 transform scale-105');
                
                // 放置后的图形
                const placedItemHtml = isPlaced ? `
                    <div class="absolute inset-0 animate-bounce-short z-10 block-3d-effect drop-shadow-xl">
                        ${createShapeSvg(item)}
                        <div class="absolute -top-2 -right-2 bg-green-500 text-white rounded-full p-1 shadow-lg transform scale-0 animate-pop-in" style="animation-fill-mode: forwards;">
                           ${getLucideSvgString('check', { width: 20, height: 20, strokeWidth: 4 })}
                        </div>
                    </div>
                ` : '';

                return `
                    <div 
                      data-item-id="${item.id}"
                      data-item-type="${item.type}"
                      data-item-color="${item.color}"
                      class="slot-target relative w-24 h-24 sm:w-32 sm:h-32 transition-all duration-500 ${isPlaced ? 'scale-110' : ''}"
                    >
                        <!-- Outline/Hole -->
                        <div class="absolute inset-0">
                            ${outlineSvg}
                        </div>
                        <!-- Placed Item -->
                        ${placedItemHtml}
                    </div>
                `;
            }).join('');
            
            // Collect slot positions AFTER rendering
            document.querySelectorAll('.slot-target').forEach(el => {
                // Store minimal item info and its current position
                gameState.slotsRects[el.dataset.itemId] = {
                    rect: el.getBoundingClientRect(),
                    type: el.dataset.itemType,
                    color: el.dataset.itemColor,
                };
            });
        }

        function renderPieces() {
            DOMElements.piecesGrid.innerHTML = gameState.shuffledPieces.map(item => {
                const isPlaced = gameState.placedItems[item.id];
                // 拖动中的积木在底部分区隐藏
                const isDraggingThis = gameState.draggingItem?.id === item.id;
                
                if (isPlaced || isDraggingThis) return '';

                return `
                    <div 
                       data-item-id="${item.id}"
                       data-item-type="${item.type}"
                       data-item-color="${item.color}"
                       class="w-20 h-20 sm:w-24 sm:h-24 cursor-grab active:cursor-grabbing transform transition-transform hover:scale-105"
                       onpointerdown="handlePointerDown(event, this.dataset)"
                    >
                       <!-- Visual styling to make it look like a wooden block 3D -->
                       <div class="block-3d-effect">
                           ${createShapeSvg(item)}
                       </div>
                    </div>
                `;
            }).join('');
        }

        function renderDragLayer() {
            const item = gameState.draggingItem;
            if (item) {
                DOMElements.dragLayer.innerHTML = createShapeSvg(item);
                DOMElements.dragLayer.style.left = `${gameState.dragPosition.x}px`;
                DOMElements.dragLayer.style.top = `${gameState.dragPosition.y}px`;
                DOMElements.dragLayer.classList.remove('hidden');
                DOMElements.dragLayer.style.transform = 'scale(1.2)';
            } else {
                DOMElements.dragLayer.classList.add('hidden');
            }
        }
        
        function renderFeedback(type, x, y) {
            // 使用 width/height 替代 size
            DOMElements.feedbackLayer.innerHTML = type === 'success' ? 
                getLucideSvgString('check', { width: 48, height: 48, class: 'text-green-500 drop-shadow-lg', strokeWidth: 4 }) : 
                getLucideSvgString('x', { width: 48, height: 48, class: 'text-red-500 drop-shadow-lg', strokeWidth: 4 });

            DOMElements.feedbackLayer.style.left = `${x - 24}px`;
            DOMElements.feedbackLayer.style.top = `${y - 24}px`;
            DOMElements.feedbackLayer.classList.remove('hidden');
            DOMElements.feedbackLayer.classList.add('animate-fade-out');

            setTimeout(() => {
                DOMElements.feedbackLayer.classList.add('hidden');
                DOMElements.feedbackLayer.classList.remove('animate-fade-out');
            }, 1000);
        }

        function renderModal() {
            const isFinalLevel = gameState.currentLevelIdx === LEVELS.length - 1;
            const title = isFinalLevel ? "恭喜你，完成所有挑战！" : "太棒了!";
            const iconSvg = isFinalLevel ? 
                getLucideSvgString('trophy', { width: 64, height: 64, fill: "currentColor", class: "animate-spin-slow" }) :
                getLucideSvgString('star', { width: 64, height: 64, fill: "currentColor", class: "animate-spin-slow" });

            const buttonText = isFinalLevel ? "重玩全部" : "下一关";
            const currentLevelName = LEVELS[gameState.currentLevelIdx].name;

            DOMElements.modal.innerHTML = `
                <div class="bg-white rounded-3xl p-8 max-w-sm w-[90%] text-center shadow-2xl transform scale-100 animate-bounce-in relative overflow-hidden">
                    <div class="absolute inset-0 bg-yellow-100 opacity-50 z-0"></div>
                    
                    <div class="relative z-10 flex flex-col items-center">
                       <div class="mb-4 text-yellow-500">${iconSvg}</div>
                       <h2 class="text-3xl font-black text-gray-800 mb-2">${title}</h2>
                       <p class="text-gray-500 mb-8">你完成了${currentLevelName}</p>
                       
                       <div class="flex gap-4 w-full">
                         <button 
                           onclick="startLevel(${gameState.currentLevelIdx})"
                           class="flex-1 py-3 rounded-xl bg-gray-100 text-gray-600 font-bold text-lg hover:bg-gray-200 transition-colors"
                         >
                           再玩一次
                         </button>
                         <button 
                           onclick="nextLevel()"
                           class="flex-1 py-3 rounded-xl bg-blue-500 text-white font-bold text-lg shadow-lg shadow-blue-500/30 hover:bg-blue-600 hover:scale-105 transition-all flex items-center justify-center gap-2"
                         >
                           ${getLucideSvgString('play', { width: 20, height: 20, fill: "currentColor" })}
                           ${buttonText}
                         </button>
                       </div>
                    </div>
                    <!-- Confetti effects -->
                    <div class="absolute top-10 left-10 w-4 h-4 bg-red-500 rounded-full animate-ping"></div>
                    <div class="absolute top-20 right-20 w-3 h-3 bg-blue-500 rounded-full animate-ping delay-100"></div>
                    <div class="absolute bottom-40 left-1/3 w-5 h-5 bg-green-500 rounded-full animate-ping delay-200"></div>
                </div>
            `;
        }

        function renderGame() {
            renderHeader();
            renderSlots();
            renderPieces();
            renderDragLayer();
        }

        // --- 拖放事件处理 ---
        
        /**
         * 启动拖动
         */
        function handlePointerDown(e, itemData) {
            e.preventDefault(); 
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const targetRect = e.currentTarget.getBoundingClientRect();
            
            // 设置偏移量，让拖动从点击位置开始
            gameState.dragOffset = {
                x: clientX - targetRect.left,
                y: clientY - targetRect.top
            };

            // 储存正在拖动的积木信息
            gameState.draggingItem = {
                id: itemData.itemId,
                type: itemData.itemType,
                color: itemData.itemColor
            };

            // 初始拖动位置
            gameState.dragPosition = { 
                x: clientX - gameState.dragOffset.x, 
                y: clientY - gameState.dragOffset.y 
            };
            
            // 重新渲染，隐藏底部的积木并显示拖动浮层
            renderPieces();
            renderDragLayer();

            // 绑定全局事件
            window.addEventListener('pointermove', handlePointerMove, { passive: false });
            window.addEventListener('pointerup', handlePointerUp);
            window.addEventListener('touchmove', handlePointerMove, { passive: false });
            window.addEventListener('touchend', handlePointerUp);
        }

        /**
         * 处理拖动过程
         */
        function handlePointerMove(e) {
            if (!gameState.draggingItem) return;
            e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // 更新拖动位置
            gameState.dragPosition = {
                x: clientX - gameState.dragOffset.x,
                y: clientY - gameState.dragOffset.y
            };
            
            renderDragLayer();
        }

        /**
         * 结束拖动并检查匹配
         */
        function handlePointerUp(e) {
            if (!gameState.draggingItem) return;

            // 解绑全局事件
            window.removeEventListener('pointermove', handlePointerMove);
            window.removeEventListener('pointerup', handlePointerUp);
            window.removeEventListener('touchmove', handlePointerMove);
            window.removeEventListener('touchend', handlePointerUp);

            let matched = false;
            const dragItem = gameState.draggingItem;
            
            // 积木的中心点，用于碰撞检测（假设拖动浮层是 96x96px，中心点约在 48px）
            const dragBlockSize = DOMElements.dragLayer.clientWidth || 96; // Fallback to 96px (sm:w-24)
            const centerOffset = dragBlockSize / 2;
            const dropX = gameState.dragPosition.x + centerOffset; 
            const dropY = gameState.dragPosition.y + centerOffset;

            // 遍历所有目标槽位的边界框进行碰撞检测
            for (const itemId in gameState.slotsRects) {
                const slot = gameState.slotsRects[itemId];
                const rect = slot.rect;
                
                // 碰撞检测：判断拖动积木的中心点是否在目标槽位内
                if (
                    dropX >= rect.left && dropX <= rect.right &&
                    dropY >= rect.top && dropY <= rect.bottom
                ) {
                    
                    // --- 严格匹配逻辑: 形状和颜色必须同时匹配 ---
                    if (slot.type === dragItem.type && slot.color === dragItem.color) {
                         // 成功匹配
                         if (!gameState.placedItems[dragItem.id]) { // 确保未重复放置
                            gameState.placedItems[dragItem.id] = true;
                            matched = true;
                            renderFeedback('success', rect.left + rect.width / 2, rect.top + rect.height / 2);
                         }

                         // 检查胜利条件
                         if (Object.keys(gameState.placedItems).length === LEVELS[gameState.currentLevelIdx].items.length) {
                             setTimeout(handleLevelComplete, 500);
                         }
                    } else {
                         // 形状或颜色不匹配
                         renderFeedback('error', rect.left + rect.width / 2, rect.top + rect.height / 2);
                    }
                    break; 
                }
            }

            // 清除拖动状态，并重新渲染游戏区域
            gameState.draggingItem = null;
            renderGame();
        }


        // --- 初始化 ---
        window.onload = function() {
            startLevel(0); // 启动第一关
        };
    </script>
</body>

</html>
